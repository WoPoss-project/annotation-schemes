<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:lang="en"
    xmlns:sch="http://purl.oclc.org/dsdl/schematron">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>TEI WoPoss: corpus schema</title>
                <author>Helena Bermúdez Sabel</author>
                <principal>Francesca Dell’Oro</principal>
                <funder>Swiss National Science Foundation</funder>
            </titleStmt>
            <publicationStmt>
                <distributor>Institut des sciences du langage (University of
                    Neuchâtel)</distributor>
                <availability status="free">
                    <licence target="http://creativecommons.org/licenses/by-nc/4.0/">Creative
                        Commons BY-NC</licence>
                </availability>
                <date>2022</date>
            </publicationStmt>
            <notesStmt>
                <note type="ns">https://woposs.unine.ch/</note>
            </notesStmt>
            <sourceDesc>
                <p>Written from scratch.</p>
            </sourceDesc>
        </fileDesc>
    </teiHeader>
    <text>
        <body>
            <head>TEI WoPoss</head>
            <p>TEI schema for a linguistically annotated corpus.</p>
            <schemaSpec ident="tei_woposs" start="TEI teiCorpus">
                <moduleRef n="01" key="tei"/>
                <moduleRef n="02" key="header"/>
                <moduleRef n="03" key="core"/>
                <moduleRef n="04" key="textstructure"/>
                <moduleRef n="06" key="verse"/>
                <moduleRef n="07" key="drama"/>
                <moduleRef n="17" key="analysis"/>
                <moduleRef n="10" key="msdescription"/>
                <moduleRef n="11" key="transcr"/>
                <moduleRef n="12" key="textcrit"/>
                <moduleRef n="13" key="namesdates"/>
                <moduleRef n="14" key="figures"/>
                <moduleRef n="15" key="corpus"/>
                <moduleRef n="16" key="linking"/>
                <moduleRef n="18" key="iso-fs"/>
                <moduleRef n="21" key="certainty"/>

                <!-- Metadata-->
                <elementSpec ident="person" module="namesdates" mode="change">
                    <constraintSpec ident="person_namesdates" scheme="schematron">
                        <constraint>
                            <sch:rule context="tei:person[@role eq 'author']">
                                <sch:let name="path"
                                    value="substring-before(base-uri(current()), 'data')"/>
                                <sch:let name="fileName" value="concat($path, 'aux/metadata.xml')"/>
                                <sch:let name="indexAuthors"
                                    value="doc($fileName)//tei:TEI/descendant::tei:person"/>
                                <sch:assert test="substring(@corresp, 2) = $indexAuthors/@xml:id">ID
                                    not found in metadata master file</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>

                <elementSpec ident="TEI" module="textstructure" mode="change">
                    <constraintSpec ident="TEI_textstructure" scheme="schematron">
                        <constraint>
                            <sch:rule context="tei:TEI">
                                <sch:let name="path"
                                    value="substring-before(base-uri(current()), 'data')"/>
                                <sch:let name="fileName" value="concat($path, 'aux/metadata.xml')"/>
                                <sch:let name="indexWorks"
                                    value="doc($fileName)//tei:TEI/descendant::tei:bibl"/>
                                <sch:assert test="@xml:id = $indexWorks/@xml:id">ID not found in
                                    metadata master file</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>

                <elementSpec ident="w" module="analysis" mode="change">
                    <constraintSpec scheme="schematron" ident="w_analysis">
                        <desc/>
                        <constraint>
                            <!-- Words within modal passages -->
                            <sch:rule
                                context="tei:w[(ancestor::tei:seg or descendant::tei:seg) and not(ancestor::tei:supplied)]">
                                <!-- Linguistic annotation-->
                                <sch:assert test="
                                    if (not(@pos = ('ADV', 'ADP', 'INTJ', 'NUM', 'CCONJ', 'SCONJ', 'X')) and not(starts-with(@lemma, 'necess'))) then
                                    @msd
                                    else
                                    true()">Morphological analysis
                                    missing</sch:assert>
                                <sch:assert
                                    test="@pos = ('ADJ', 'ADP', 'ADV', 'CCONJ', 'INTJ', 'NOUN', 'NUM',
                                    'PRON', 'PROPN', 'PUNCT', 'SCONJ', 'VERB', 'X') and @lemma"
                                    >The @lemma is mandatory and @pos attribute must have one of
                                    these values: ADJ – ADP – ADV – CCONJ – INTJ – NOUN – NUM – PRON
                                    – PROPN – PUNCT – SCONJ – VERB – X </sch:assert>
                                <!-- PoS relation with morphological features-->
                                <sch:assert test="
                                    if (@pos = 'VERB') then contains(@msd, 'VerbForm') else true()"
                                    >Verbs must have a feature VerbForm</sch:assert>
                                <sch:assert test="
                                    if (@pos = ('NOUN', 'ADJ', 'PRON') and not(starts-with(@lemma, 'necess'))) then contains(@msd, 'Gender') else true()"
                                    >Nouns, adjectives and pronouns must have a feature
                                    Gender</sch:assert>
                                <!-- Morphological features dependencies-->
                                <sch:assert
                                    test="if (contains(@msd, 'Tense=Past')) then matches(@msd, 'Aspect') else true()"
                                    >Aspect feature is mandatory with past tenses</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'VerbForm=Fin')) then contains(@msd, 'Person') and contains(@msd, 'Number') and contains(@msd, 'Mood') and contains(@msd, 'Tense') else true()"
                                    >Person, Number, Mood and Tense features are mandatory with
                                    finite forms</sch:assert>
                                <sch:assert
                                    test="if (matches(@msd, 'VerbForm=(Gdv|Part)')) then contains(@msd, 'Case') and contains(@msd, 'Gender') and contains(@msd, 'Number') else true()"
                                    >Case, Gender and Number features are mandatory</sch:assert>
                                <sch:assert
                                    test="if (matches(@msd, 'VerbForm=(Gdv|Part)')) then contains(@msd, 'Case') and contains(@msd, 'Gender') and contains(@msd, 'Number') else true()"
                                    >Case, Gender and Number features are mandatory</sch:assert>
                                <!-- Values of morphological features -->
                                <sch:assert
                                    test="if (contains(@msd, 'Tense')) then matches(@msd, 'Tense=(Fut|Past|Pqp|Pres)\||$') else true()"
                                    > Possible values for Tense = Fut, Past, Pqp, Pres </sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Aspect')) then matches(@msd, 'Aspect=(Imp|Perf)\||$') else true()"
                                    > Possible values for Aspect = Imp, Perf</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Number')) then matches(@msd, 'Number=(Plur|Sing)\||$') else true()"
                                    > Possible values for Number = Plur, Sing</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'VerbForm')) then matches(@msd, 'Tense=(Fin|Gdv|Ger|Inf|Part)\||$') else true()"
                                    >Possible values for VerbForm = Fin, Gdv, Ger, Inf, Part </sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Voice')) then matches(@msd, 'Voice=(Act|Pass)\||$') else true()"
                                    > Possible values for Voice = Act, Pass</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Mood')) then matches(@msd, 'Mood=(Imp|Ind|Sub)\||$') else true()"
                                    > Possible values for Mood = Imp, Ind, Sub</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Person')) then matches(@msd, 'Person=(1|2|3)\||$') else true()"
                                    > Possible values for Person = 1, 2, 3</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Gender')) then matches(@msd, 'Gender=(Masc|Fem|Neut)\||$') else true()"
                                    > Possible values for Gender = Masc, Fem, Neut</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Case')) then matches(@msd, 'Case=(Abl|Acc|Dat|Gen|Loc|Nom|Voc)\||$') else true()"
                                    > Possible values for Case = Abl, Acc, Dat, Gen, Loc, Nom,
                                    Voc</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Degree')) then matches(@msd, 'Degree=(Cmp|Pos|Sup)\||$') else true()"
                                    > Possible values for Degree = Cmp, Pos, Sup</sch:assert>
                                <!-- Check whether all potential modal markers have been annotated-->
                                <sch:let name="lemma_markers" value="
                                    ('aequus', 'iniquus', 'aptus', 'ineptus', 'certus', 'incertus',
                                    'dubius', 'illicitus', 'licitus', 'necessarius', 'certo', 'dubium', 'necessarium', 'necessario', 'facultas',
                                    'possibilitas', 'potestas', 'necessitas', 'necessitudo', 'probabilitas', 'voluntas', 'certe', 'dubie', 'forsitan',
                                    'forstan', 'fortasse', 'indubitate', 'indubitanter', 'necessarie', 'possibiliter', 'probabiliter', 'debeo', 'possum',
                                    'nequeo', 'queo', 'malo', 'volo', 'nolo', 'licet', 'decet', 'oportet', 'valeo', 'valet', 'necesse', 'ius')"/>
                                <sch:report
                                    test="if (not(@function) and not(ancestor::tei:seg[@function eq 'marker']) and not(descendant::tei:seg[@function eq 'marker']))
                                    then @lemma = $lemma_markers else false()"
                                    >Potential modal marker (lemma)</sch:report>
                                <sch:report
                                    test="if (not(@function) and not(ancestor::tei:seg[@function eq 'marker']) and not(descendant::tei:seg[@function eq 'marker'])
                                    and @pos eq 'VERB' and matches(., '[ae]nd[aeiou][smeoa]?(rum)?$') and @lemma[not(contains(., 'nd'))]) then true()
                                    else false()">Potential
                                    modal marker (ndus)</sch:report>
                                <sch:report
                                    test="if (tei:w[not(@function) and not(ancestor::tei:seg[@function eq 'marker']) and not(descendant::tei:seg[@function eq 'marker'])] and
                                    @pos eq 'ADJ' and matches(@lemma, '[ai]bilis')) then true
                                    else false()">Potential
                                    modal marker (bilis)</sch:report>
                                <sch:report
                                    test="if (not(@function) and not(ancestor::tei:seg[@function eq 'marker']) and not(descendant::tei:seg[@function eq 'marker']) and
                                    @pos eq 'VERB' and matches(., '.+tur[aeiou][smeoa]?(rum)?') and @lemma[not(contains(., 'tur'))]) then true() 
                                    else false()">Potential
                                    modal marker (turus)</sch:report>
                            </sch:rule>
                            <!-- Wods outside modal passages -->
                            <sch:rule
                                context="tei:w[not(ancestor::tei:seg or descendant::tei:seg) and not(ancestor::tei:supplied)]">
                                <!-- Linguistic annotation-->
                                <sch:assert
                                    test="if (not(@pos = ('ADV', 'ADP', 'INTJ', 'NUM', 'CCONJ', 'SCONJ', 'X')) and not(starts-with(@lemma, 'necess'))) then
                                    @msd
                                    else
                                    true()" role="WARN"
                                    >Morphological analysis missing</sch:assert>
                                <sch:assert
                                    test="@pos = ('ADJ', 'ADP', 'ADV', 'CCONJ', 'INTJ', 'NOUN', 'NUM',
                                    'PRON', 'PROPN', 'PUNCT', 'SCONJ', 'VERB', 'X') and @lemma"
                                    role="WARN">This word does not contain a lemma attributes and/or
                                    the @pos attribute does not have one of the acceptable values
                                    (ADJ – ADP – ADV – CCONJ – INTJ – NOUN – NUM – PRON – PROPN –
                                    PUNCT – SCONJ – VERB – X )</sch:assert>
                                <!-- PoS relation with morphological features-->
                                <sch:assert test="
                                    if (@pos = 'VERB') then contains(@msd, 'VerbForm') else true()"
                                    role="WARN">Verbs must have a feature VerbForm</sch:assert>
                                <sch:assert test="
                                    if (@pos = ('NOUN', 'ADJ', 'PRON') and not(starts-with(@lemma, 'necess'))) then contains(@msd, 'Gender') else true()"
                                    role="WARN">Nouns, adjectives and pronouns must have a feature
                                    Gender</sch:assert>
                                <!-- Morphological features dependencies-->
                                <sch:assert
                                    test="if (contains(@msd, 'Tense=Past')) then matches(@msd, 'Aspect') else true()"
                                    role="WARN">Aspect feature is mandatory with past
                                    tenses</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'VerbForm=Fin')) then contains(@msd, 'Person') and contains(@msd, 'Number') and contains(@msd, 'Mood') and contains(@msd, 'Tense') else true()"
                                    role="WARN">Person, Number, Mood and Tense features are
                                    mandatory with finite forms</sch:assert>
                                <sch:assert
                                    test="if (matches(@msd, 'VerbForm=(Gdv|Part)')) then contains(@msd, 'Case') and contains(@msd, 'Gender') and contains(@msd, 'Number') else true()"
                                    role="WARN">Case, Gender and Number features are
                                    mandatory</sch:assert>
                                <sch:assert
                                    test="if (matches(@msd, 'VerbForm=(Gdv|Part)')) then contains(@msd, 'Case') and contains(@msd, 'Gender') and contains(@msd, 'Number') else true()"
                                    role="WARN">Case, Gender and Number features are
                                    mandatory</sch:assert>
                                <!-- Values of morphological features -->
                                <sch:assert
                                    test="if (contains(@msd, 'Tense')) then matches(@msd, 'Tense=(Fut|Past|Pqp|Pres)\||$') else true()"
                                    role="WARN"> Possible values for Tense = Fut, Past, Pqp, Pres </sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Aspect')) then matches(@msd, 'Aspect=(Imp|Perf)\||$') else true()"
                                    role="WARN"> Possible values for Aspect = Imp, Perf</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Number')) then matches(@msd, 'Number=(Plur|Sing)\||$') else true()"
                                    role="WARN"> Possible values for Number = Plur,
                                    Sing</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'VerbForm')) then matches(@msd, 'Tense=(Fin|Gdv|Ger|Inf|Part)\||$') else true()"
                                    role="WARN">Possible values for VerbForm = Fin, Gdv, Ger, Inf,
                                    Part </sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Voice')) then matches(@msd, 'Voice=(Act|Pass)\||$') else true()"
                                    role="WARN"> Possible values for Voice = Act, Pass</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Mood')) then matches(@msd, 'Mood=(Imp|Ind|Sub)\||$') else true()"
                                    role="WARN"> Possible values for Mood = Imp, Ind,
                                    Sub</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Person')) then matches(@msd, 'Person=(1|2|3)\||$') else true()"
                                    role="WARN"> Possible values for Person = 1, 2, 3</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Gender')) then matches(@msd, 'Gender=(Masc|Fem|Neut)\||$') else true()"
                                    role="WARN"> Possible values for Gender = Masc, Fem,
                                    Neut</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Case')) then matches(@msd, 'Case=(Abl|Acc|Dat|Gen|Loc|Nom|Voc)\||$') else true()"
                                    role="WARN"> Possible values for Case = Abl, Acc, Dat, Gen, Loc,
                                    Nom, Voc</sch:assert>
                                <sch:assert
                                    test="if (contains(@msd, 'Degree')) then matches(@msd, 'Degree=(Cmp|Pos|Sup)\||$') else true()"
                                    role="WARN"> Possible values for Degree = Cmp, Pos,
                                    Sup</sch:assert>
                                <!-- Check whether all potential modal markers have been annotated-->
                                <sch:let name="lemma_markers" value="
                                    ('aequus', 'iniquus', 'aptus', 'ineptus', 'certus', 'incertus',
                                    'dubius', 'illicitus', 'licitus', 'necessarius', 'certo', 'dubium', 'necessarium', 'necessario', 'facultas',
                                    'possibilitas', 'potestas', 'necessitas', 'necessitudo', 'probabilitas', 'voluntas', 'certe', 'dubie', 'forsitan',
                                    'forstan', 'fortasse', 'indubitate', 'indubitanter', 'necessarie', 'possibiliter', 'probabiliter', 'debeo', 'possum',
                                    'nequeo', 'queo', 'malo', 'volo', 'nolo', 'licet', 'decet', 'oportet', 'valeo', 'valet', 'necesse', 'ius')"/>
                                <sch:report
                                    test="if (not(@function) and not(ancestor::tei:seg[@function eq 'marker']) and not(descendant::tei:seg[@function eq 'marker']))
                                    then @lemma = $lemma_markers else false()"
                                    >Potential modal marker (lemma)</sch:report>
                                <sch:report
                                    test="if (not(@function) and not(ancestor::tei:seg[@function eq 'marker']) and not(descendant::tei:seg[@function eq 'marker'])
                                    and @pos eq 'VERB' and matches(., '[ae]nd[aeiou][smeoa]?(rum)?$') and @lemma[not(contains(., 'nd'))]) then true()
                                    else false()">Potential
                                    modal marker (ndus)</sch:report>
                                <sch:report
                                    test="if (tei:w[not(@function) and not(ancestor::tei:seg[@function eq 'marker']) and not(descendant::tei:seg[@function eq 'marker'])] and
                                    @pos eq 'ADJ' and matches(@lemma, '[ai]bilis')) then true
                                    else false()">Potential
                                    modal marker (bilis)</sch:report>
                                <sch:report
                                    test="if (not(@function) and not(ancestor::tei:seg[@function eq 'marker']) and not(descendant::tei:seg[@function eq 'marker']) and
                                    @pos eq 'VERB' and matches(., '.+tur[aeiou][smeoa]?(rum)?') and @lemma[not(contains(., 'tur'))]) then true() 
                                    else false()">Potential
                                    modal marker (turus)</sch:report> </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>

                <elementSpec ident="s" module="analysis" mode="change">
                    <constraintSpec scheme="schematron" ident="s">
                        <desc/>
                        <constraint>
                            <sch:rule context="tei:s">
                                <sch:report test="text()[matches(., '\S')]">No text nodes allowed as
                                    children of s</sch:report>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>

                <elementSpec ident="ex" module="transcr" mode="change">
                    <desc>This element is also part of model.segLike</desc>
                    <classes mode="change">
                        <memberOf key="model.segLike"/>
                    </classes>
                </elementSpec>

                <elementSpec ident="note" module="core" mode="change">
                    <constraintSpec scheme="schematron" ident="note_consistency">
                        <desc/>
                        <constraint>
                            <sch:rule context="tei:note">
                                <sch:report test="string-length(.) eq 0">Empty note</sch:report>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>

                <elementSpec ident="seg" module="linking" mode="change">
                    <constraintSpec scheme="schematron" ident="seg_analysis">
                        <desc>Constraints to check the consistency of the semantic analysis</desc>
                        <constraint>
                            <sch:rule context="tei:seg">
                                <sch:let name="function" value="@function"/>
                                <sch:let name="functions"
                                    value="('participant', 'negation', 'scope', 'marker')"/>
                                <sch:let name="part_types"
                                    value="('animate', 'inanimate', 'inanimate_patient', 'animate_patient')"/>
                                <sch:let name="ana" value="
                                    for $x in tokenize(@ana, '\s+')
                                    return
                                    substring($x, 2)"/>
                                <sch:assert test="@function = $functions">@function attribute is
                                    mandatory with one of these values: <sch:value-of
                                        select="$functions"/></sch:assert>
                                <sch:assert test="
                                    if (@ana) then
                                    every $x in tokenize(@ana, '\s+')
                                    satisfies substring($x, 2) = //tei:fs[@type eq current()/@function]/@xml:id
                                    else
                                    true()">@ana does not have a
                                    corresponding ID in feature structures</sch:assert>
                                <sch:assert test="
                                    if (@part eq 'Y') then @ana or @corresp
                                    else
                                    true()">@part requires the
                                    presence of an @ana or @corresp attribute</sch:assert>
                                <sch:report test="tei:w/following-sibling::text()[matches(., '\S')]"
                                    >Segmentation issue (this string should be inside a w or pc
                                    element</sch:report>
                                <sch:report test="descendant::tei:seg[@ana eq current()/@ana]"
                                    >Unnecessary nested segs</sch:report>
                                <sch:report test="
                                    if (@function eq 'marker') then
                                    descendant::tei:seg[@function eq 'marker']
                                    else
                                    false()">Unnecessary nested
                                    segs</sch:report>
                                <sch:assert test="
                                    if (@function eq 'participant') then
                                    @type = $part_types
                                    else
                                    true()">Attribute @type is
                                    mandatory with one of these values: <sch:value-of
                                        select="$part_types"/></sch:assert>
                                <sch:assert test="
                                    if (@function eq 'participant') then
                                    every $x in tokenize(@corresp, '\s+')
                                    satisfies substring($x, 2) = //tei:fs[@type eq 'scope']/@xml:id
                                    else
                                    true()">Attribute @corresp is
                                    missing or no corresponding ID was found in feature
                                    structures</sch:assert>
                                <sch:assert test="
                                    if (@function eq 'negation') then
                                    every $x in tokenize(@corresp, '\s+')
                                    satisfies substring($x, 2) = //tei:fs[@type = ('marker', 'scope')]/@xml:id
                                    else
                                    true()">Attribute @corresp is
                                    missing or no corresponding ID was found in feature
                                    structures</sch:assert>
                                <sch:assert test="
                                    if (@function = ('scope', 'marker')) then
                                   @ana
                                    else
                                    true()">@ana attribute is
                                    missing</sch:assert>
                                <sch:report test="
                                    if (@ana and not(@part)) then
                                    (following::tei:seg[some $x in tokenize(@ana, '\s+')
                                    satisfies $x = $ana] or preceding::tei:seg[some $x in tokenize(@ana, '\s+')
                                    satisfies $x = $ana])
                                    else
                                    false()">@part attribute
                                    missing</sch:report>
                                <sch:let name="explicit_participants"
                                    value="for $x in //tei:seg[@function eq 'participant']/tokenize(@corresp, '\s+')
                                    return
                                    substring($x, 2)"/>
                                <sch:assert test="
                                    if (@function = 'scope' and //tei:fs[@xml:id = $ana]/tei:f[@name = 'participant']/tei:symbol/@value = 'explicit') then 
                                    every $id in $ana satisfies $id = $explicit_participants                      
                                    else
                                    true()">If the participant is
                                    not explicit, the analysis of the scope must include an implicit
                                    participant</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>
                <elementSpec ident="fs" module="iso-fs" mode="change">
                    <constraintSpec scheme="schematron" ident="seg_analysis">
                        <desc>Constraints to check the consistency of the semantic analysis</desc>
                        <constraint>
                            <sch:rule
                                context="tei:fs[@type eq 'marker'][tei:f[@name eq 'pertinence'][tei:binary[@value eq 'true']]]">
                               
                                <sch:assert test="tei:f[@name eq 'polarity']">Missing 'polarity'
                                    feature</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:fs[@type eq 'scope'][tei:f[@name eq 'dynamicity']]">
                                <sch:assert test="tei:f[@name eq 'control']">Missing 'control'
                                    feature</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:fs[@type eq 'scope'][tei:f[@name eq 'control']]">
                                <sch:assert test="tei:f[@name eq 'dynamicity']">Missing 'dynamicity'
                                    feature</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:fs[@type eq 'relation'][tei:f[@name eq 'modality'][tei:symbol[@value eq 'dynamic']]]">                                
                                <sch:assert
                                    test="tei:f[@name eq 'meaning']/tei:symbol/@value = ('possibility', 'necessity')"
                                    >Possible values of feature 'type' are 'possibility'
                                    'necessity'</sch:assert>
                                <sch:assert
                                    test="tei:f[@name eq 'type']/tei:symbol[@value = ('participant-imposed', 'participant-inherent', 'situational')]"
                                    > Incorrect value of @value within feature “type”. Possible values are:
                                    'participant-imposed, participant-inherent,
                                    situational'</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:fs[@type eq 'relation'][tei:f[@name eq 
                                'type'][tei:symbol[@value eq 'authority']]]">
                                <sch:assert test="tei:f[@name eq 'subtype']">Missing 'subtype'
                                    feature</sch:assert>
                                <sch:assert test="tei:f[@name eq 'subtype']/tei:symbol/@value =
                                    ('obligation', 'recommendation', 'permission')"
                                    > Possible values of feature 'subtype' are 'obligation'
                                    'recommendation' 'permission' </sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:fs[@type eq 'relation'][tei:f[@name eq 'type'][tei:symbol[@value eq 'acceptability']]]">
                                <sch:assert test="tei:f[@name eq 'degree']">Missing 'degree' feature </sch:assert>
                                <sch:assert
                                    test="tei:f[@name eq 'degree']/tei:symbol/@value = ('absolutely_necessary', 'desirable', 'acceptable', 'undesirable', 'unacceptable')"
                                    >Possible values of 'degree' feature are 'absolutely_necessary'
                                    'desirable' 'acceptable' 'undesirable'
                                    'unacceptable'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:fs[@type eq 'relation'][tei:f[@name eq 'modality'][tei:symbol[@value eq 'epistemic']]]">
                                <sch:assert test="tei:f[@name eq 'degree']">Missing 'degree'
                                    feature</sch:assert>
                                <sch:assert
                                    test="tei:f[@name eq 'degree']/tei:symbol/@value = ('absolutely_certain', 'probable', 'possible', 'improbable', 'impossible')"
                                    >Possible values of 'degree' feature are 'absolutely_certain'
                                    'probable' 'possible' 'improbable' 'impossible'</sch:assert>
                            </sch:rule>
                            
                            <sch:rule context="tei:fs[@type eq 'scope']">
                                <sch:let name="scope"
                                    value="//tei:seg[some $x in tokenize(@ana, '\s+') satisfies $x = '#' || current()/@xml:id]"/>
                                <sch:let name="participant"
                                    value="//tei:seg[not(ancestor::tei:supplied[not(@evidence)])][@function eq 'participant'][some $x in tokenize(@corresp, '\s+') satisfies $x = '#' || current()/@xml:id]"/>
                                <sch:assert
                                    test="@xml:id = //tei:fs[@type eq 'relation']/tei:f[@name eq 'scope']/@fVal"
                                    >This scope is not part of a modal relation</sch:assert>
                                <sch:assert test="$scope">ID not referenced in text</sch:assert>                                
                                <sch:assert test="tei:f[@name = ('utterance', 'polarity')]"> The
                                    following features is required: 'utterance,
                                    polarity'</sch:assert>
                                <sch:assert
                                    test="if (tei:f[@name eq 'SoA']/tei:binary eq 'true' and not($scope/ancestor::tei:supplied) and not($scope/descendant::tei:supplied) and not($scope/parent::tei:w/tei:seg[@function eq 'marker'])) then $scope/descendant::tei:w[@function eq 'main']
                                    or $scope/ancestor::tei:w[@function eq 'main'] else true()"
                                    >Main verb of scope needs to be identified</sch:assert>
                                <sch:report
                                    test="count($scope/child::tei:w[@function eq 'main']) gt 1">More
                                    than one main verb annotated in current scope</sch:report>
                                <sch:report test="tei:f[@name eq 'SoA']/tei:binary/@value eq 'true'"
                                    >Unnecessary description of SoA</sch:report>
                                <sch:report
                                    test="if (tei:f[@name eq 'SoA']) then tei:f[@name eq 'participant'] else false()"
                                    >Unneeded description of participant</sch:report>
                                <sch:assert
                                    test="if ($participant) then tei:f[@name eq 'participant']/tei:symbol/@value eq 'explicit' else true()"
                                    >This scope should have a explicit participant in its
                                    description</sch:assert>
                                <sch:assert
                                    test="if ($participant) then tei:f[@name eq 'participantType']/tei:symbol/@value = $participant/@type else true()"
                                    >The description of the participant type is
                                    incorrect</sch:assert>
                                <sch:assert
                                    test="if (not($participant) and not(tei:f[@name eq 'SoA'])) then tei:f[@name eq 'participant']/tei:symbol/@value = ('implicit', 'none') else true()"
                                    >The description of the participant is incorrect</sch:assert>
                                <sch:assert
                                    test="if (not(tei:f[@name eq 'SoA'])) then tei:f[@name eq 'participant'] else true()"
                                    >Description of participant is missing</sch:assert>
                                <sch:assert
                                    test="if (tei:f[@name eq 'participant'] and tei:f[@name eq 'participant']/tei:symbol/@value ne 'none') then tei:f[@name eq 'participantType'] else true()"
                                    >Participant type is missing</sch:assert>
                                <sch:assert
                                    test="if (tei:f[@name eq 'participant'] and tei:f[@name eq 'participant']/tei:symbol/@value ne 'none') then tei:f[@name eq 'participantType'] else true()"
                                    >Participant type is missing</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:fs[@type eq 'marker']">
                                <sch:let name="markers" value="
                                    ('aequus', 'iniquus', 'habeo_inf', 'est_inf','aptus', 'ineptus', 'certus', 'incertus', 'bilis', 'turus', 'ndus',  
                                    'est_inf',
                                    'dubius', 'illicitus', 'licitus', 'necessarius', 'certo', 'dubium', 'necessarium', 'necessario', 'facultas',
                                    'possibilitas', 'potestas', 'necessitas', 'necessitudo', 'probabilitas', 'voluntas', 'certe', 'dubie', 'opus_est','opus_habeo', 'usus_est', 'impossibilis', 'possibilis',
                                    'forsitan', 'forsan', 'fortasse', 'forte', 'indubitate', 'necessarie', 'possibiliter', 'probabiliter', 'debeo', 'possum',
                                    'nequeo', 'queo', 'malo', 'volo', 'nolo', 'licet', 'decet', 'oportet', 'valeo', 'valet', 'necesse_est', 'necesse_habeo', 'ius_est', 'meum_est')"/>
                                <sch:assert test="
                                    some $x in //tei:body//tei:seg[@function eq 'marker']/tokenize(@ana, '\s+')
                                    satisfies $x = '#' || current()/@xml:id"
                                    >ID not referenced in text</sch:assert>
                                <sch:assert test="
                                    if (tei:f[@name eq 'pertinence']/tei:binary/@value eq 'true') then
                                    @xml:id = //tei:fs[@type eq 'relation']/tei:f[@name eq 'marker']/@fVal
                                    else
                                    true()">This marker is not part
                                    of a modal relation</sch:assert>
                                <sch:assert
                                    test="tei:f[@name eq 'lemma']/tei:symbol[@value = $markers]"
                                    >Either the citation form of the marker is missing or its value
                                    is not correct</sch:assert>
                                <sch:assert test="tei:f[@name = ('pertinence', 'modal')]"> One of
                                    the following features are required: 'pertinence',
                                    'modal'</sch:assert>
                                <sch:assert test="if (tei:f[@name eq 'pertinence'][tei:binary[@value eq 'true']]) then tei:f[@name eq 'utterance'] else true()">Missing 'utterance'
                                    feature</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:fs[@type eq 'relation']">                                
                                <sch:assert test="tei:f[@name = ('modality')]"> One of the following
                                    features is required: 'modality'</sch:assert>
                                <sch:assert
                                    test="tei:f[@name eq 'marker']/@fVal = //tei:fs[@type eq 'marker']/@xml:id"
                                    >Marker ID not available in FS</sch:assert>
                                <sch:assert
                                    test="tei:f[@name eq 'scope']/@fVal = //tei:fs[@type eq 'scope']/@xml:id"
                                    >Scope ID not available in FS</sch:assert>
                                <sch:assert test="if (tei:f[@name eq 
                                    'modality'][tei:symbol[@value eq 'deontic']]) then tei:f[@name eq 'type'] else true()">Missing tei:f[@name eq
                                    'type']</sch:assert>
                                <sch:assert test="if (tei:f[@name eq 
                                    'modality'][tei:symbol[@value eq 'deontic']]) then tei:f[@name eq 'type']/tei:symbol[@value = 
                                    ('authority', 'acceptability', 'volition', 
                                    'intention')] else true()">Possible values of
                                    feature 'type' are 'authority' 'acceptability' 'volition'
                                    'intention'</sch:assert>                                
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>
                <elementSpec ident="f" module="iso-fs" mode="change">
                    <constraintSpec scheme="schematron" ident="f_analysis">
                        <desc>Constraints to check the consistency of the semantic analysis</desc>
                        <constraint>
                            <sch:rule
                                context="tei:f[@name eq 'pertinence'][parent::tei:fs[@type eq 'marker']]">
                                <sch:assert test="tei:binary or tei:symbol/@value = 'fragmentary' "
                                    >Unless it is a fragmentary text, this is a binary
                                    feature</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'modal'][parent::tei:fs[@type eq 'marker']]">
                                <sch:assert test="tei:binary">Mandatory binary feature</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'diachrony'][parent::tei:fs[@type eq 'marker']]">
                                <sch:assert test="tei:symbol[@value = ('post-modal', 'pre-modal')]">
                                    Incorrect value of @value. Possible values are: 'post-modal,
                                    pre-modal'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'utterance'][parent::tei:fs[@type eq 'marker']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('non-interrogative', 'interrogative')]"
                                    > Incorrect value of @value. Possible values are:
                                    'non-interrogative, interrogative'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'polarity'][parent::tei:fs[@type eq 'marker']]">
                                <sch:assert test="tei:symbol[@value = ('affirmative', 'negative')]">
                                    Incorrect value of @value. Possible values are: 'affirmative,
                                    negative'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'utterance'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('non-interrogative', 'interrogative')]"
                                    > Incorrect value of @value. Possible values are:
                                    'non-interrogative, interrogative'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'polarity'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert test="tei:symbol[@value = ('affirmative', 'negative')]">
                                    Incorrect value of @value. Possible values are: 'affirmative,
                                    negative'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'control'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert test="tei:symbol[@value eq 'ambiguous'] or tei:binary">
                                    Incorrect value. Possible values are: a binary element or a
                                    symbol element with one of the following @value attributes
                                    'ambiguous'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'dynamicity'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert test="tei:symbol[@value eq 'ambiguous'] or tei:binary">
                                    Incorrect value. Possible values are: a binary element or a
                                    symbol element with one of the following @value attributes
                                    'ambiguous'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'SoA'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert
                                    test="if (tei:binary/@value eq 'true') then following-sibling::tei:f[@name eq 'dynamicity'] else true()"
                                    >If SoA is present, then control and dynamicity must be
                                    expressed</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'participantType'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('animate', 'inanimate', 'animate_patient', 'inanimate_patient')]"
                                    > Incorrect value. Possible values are: 'animate, inanimate,
                                    animate_patient, inanimate_patient'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'participant'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('implicit', 'explicit', 'none')]">
                                    Incorrect value. Possible values are: 'implicit, explicit,
                                    none'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'modality'][parent::tei:fs[@type eq 'relation']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('deontic', 'dynamic', 'epistemic')]">
                                    Incorrect value of @value. Possible values are: 'deontic,
                                    dynamic, epistemic'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'subtype'][parent::tei:fs[@type eq 'relation']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('obligation', 'recommendation', 'permission', 'prospective', 'inevitability')]"
                                    > Incorrect value of @value. Possible values are: 'obligation,
                                    recommendation, permission, prospective,
                                    inevitability'</sch:assert>
                            </sch:rule>
                          
                            <sch:rule
                                context="tei:f[@name eq 'function'][parent::tei:fs[@type eq 'relation']]">
                                <sch:assert test="tei:symbol[@value = ('rhetoric', 'pragmatic')]">
                                    Incorrect value of @value. Possible values are: 'rhetoric,
                                    pragmatic'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'context'][parent::tei:fs[@type eq 'relation']]">
                                <sch:assert test="tei:symbol[@value = ('non-official', 'official')]"
                                    > Incorrect value of @value. Possible values are: 'non-official,
                                    official'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'source'][parent::tei:fs[@type eq 'relation']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('moral/ethical_norms', 'religious_norms', 'unspecified_norms')]"
                                    > Incorrect value of @value. Possible values are:
                                    'moral/ethical_norms, religious_norms,
                                    unspecified_norms'</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>
                
<!--                editorial criteria -->
                <elementSpec ident="ex" module="transcr" mode="change">
                    <content>
                        <macroRef key="macro.paraContent"/>
                    </content>
                </elementSpec>
            </schemaSpec>
        </body>
    </text>
</TEI>
