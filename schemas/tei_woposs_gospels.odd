<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:lang="en"
    xmlns:sch="http://purl.oclc.org/dsdl/schematron">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>TEI WoPoss</title>
                <author>Helena Bermúdez Sabel</author>
            </titleStmt>
            <publicationStmt>
                <publisher>A world of possibilities. Modal pathways over an extra-long period of
                    time: the diachrony of modality in the Latin language (WoPoss)</publisher>
                <availability>
                    <licence>
                        <ref target="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative
                            Commons Attribution-NonCommercial-ShareAlike 4.0 International</ref>
                    </licence>
                </availability>
            </publicationStmt>
            <notesStmt>
                <note type="ns">https://woposs.unine.ch/</note>
            </notesStmt>
            <sourceDesc>
                <p>Written from scratch.</p>
            </sourceDesc>
        </fileDesc>
    </teiHeader>
    <text>
        <body>
            <head>TEI WoPoss</head>
            <p>TEI schema for a linguistically annotated corpus.</p>
            <schemaSpec ident="tei_woposs" start="TEI teiCorpus">
                <moduleRef n="01" key="tei"/>
                <moduleRef n="02" key="header"/>
                <moduleRef n="03" key="core"/>
                <moduleRef n="04" key="textstructure"/>
                <moduleRef n="06" key="verse"/>
                <moduleRef n="07" key="drama"/>
                <moduleRef n="17" key="analysis"/>
                <moduleRef n="10" key="msdescription"/>
                <moduleRef n="11" key="transcr"/>
                <moduleRef n="12" key="textcrit"/>
                <moduleRef n="13" key="namesdates"/>
                <moduleRef n="14" key="figures"/>
                <moduleRef n="15" key="corpus"/>
                <moduleRef n="16" key="linking"/>
                <moduleRef n="18" key="iso-fs"/>
                <moduleRef n="19" key="nets"/>
                <moduleRef n="21" key="certainty"/>

                <elementSpec ident="w" module="analysis" mode="change">
                    <constraintSpec scheme="schematron" ident="w_analysis">
                        <desc/>
                        <constraint>
                            <sch:rule context="tei:w">
                                <!-- Linguistic annotation-->
                                <sch:assert test="
                                    if (@msd) then
                                    substring(@msd, 2) = //tei:fs/@xml:id
                                    else
                                    true()">No corresponding ID
                                    found in feature structures</sch:assert>
                                <sch:assert test="
                                    if (ancestor::tei:TEI[@xml:lang eq 'la'] and (ancestor::tei:seg or descendant::tei:seg) and not(ancestor::tei:supplied) and not(@pos = ('ADV', 'ADP', 'INTJ', 'NUM', 'CCONJ', 'SCONJ')) and not(@lemma eq 'necesse')) then
                                    @msd
                                    else
                                    true()">Morphological analysis
                                    missing</sch:assert>
                                <sch:assert
                                    test="if (ancestor::tei:seg and not(ancestor::tei:supplied)) then
                                    @pos = ('ADJ', 'ADP', 'ADV', 'CCONJ', 'INTJ', 'NOUN', 'NUM',
                                    'PRON', 'PROPN', 'PUNCT', 'SCONJ', 'VERB', 'X') and @lemma else true()"
                                    >Pos tags: ADJ – ADP – ADV – CCONJ – INTJ – NOUN – NUM – PRON –
                                    PROPN – PUNCT – SCONJ – VERB – X </sch:assert>
                                <!--          PoS relation with FS morphological features-->
                                <sch:assert test="
                                    if (@pos = 'VERB' and @msd) then
                                    substring(@msd, 2) = //tei:fs[tei:f[@name = 'VerbForm']]/@xml:id
                                    else
                                    true()">Verbs must have a
                                    feature VerbForm</sch:assert>
                                <sch:assert test="
                                    if (@pos = ('NOUN', 'ADJ', 'PRON') and @msd) then
                                    substring(@msd, 2) = //tei:fs[tei:f[@name = 'Gender']]/@xml:id
                                    else
                                    true()">Nouns must have a
                                    feature Gender</sch:assert>
                            </sch:rule>
                            <!-- Check whether all potential modal markers have been annotated-->
                            <sch:rule
                                context="tei:w[not(@function)][not(ancestor::tei:seg[@function eq 'marker'])][not(descendant::tei:seg[@function eq 'marker'])]">
                                <sch:let name="lemma_markers" value="
                                ('aequus', 'iniquus', 'aptus', 'ineptus', 'certus', 'incertus',
                                'dubius', 'illicitus', 'licitus', 'necessarius', 'certo', 'dubium', 'necessarium', 'necessario', 'facultas',
                                'possibilitas', 'potestas', 'necessitas', 'necessitudo', 'probabilitas', 'voluntas', 'certe', 'dubie', 'forsitam',
                                'forstan', 'fortasse', 'indubitate', 'indubitanter', 'necessarie', 'possibiliter', 'probabiliter', 'debeo', 'possum',
                                'nequeo', 'queo', 'malo', 'volo', 'nolo', 'licet', 'decet', 'oportet', 'valeo', 'valet', 'necesse', 'ius')"/>
                                <sch:report test="@lemma = $lemma_markers">Potential modal
                                    marker</sch:report>
                                <sch:report
                                    test="@pos eq 'VERB' and matches(., '[ae]nd[aeiou][smeoa]?(rum)?$') and @lemma[not(contains(., 'nd'))]"
                                    >Potential modal marker</sch:report>
                                <sch:report test="@pos eq 'ADJ' and matches(@lemma, '[ai]bilis')"
                                    >Potential modal marker</sch:report>
                                <sch:report
                                    test="@pos eq 'VERB' and matches(., '.+tur[aeiou][smeoa]?(rum)?') and @lemma[not(contains(., 'tur'))]"
                                    >Potential modal marker</sch:report>
                            </sch:rule></constraint>
                    </constraintSpec>
                </elementSpec>

                <elementSpec ident="s" module="analysis" mode="change">
                    <constraintSpec scheme="schematron" ident="s">
                        <desc/>
                        <constraint>
                            <sch:rule context="tei:s">
                                <sch:report test="text()[matches(., '\S')]">No text nodes allowed as
                                    children of s</sch:report>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>

                <elementSpec ident="note" module="core" mode="change">
                    <constraintSpec scheme="schematron" ident="note_consistency">
                        <desc/>
                        <constraint>
                            <sch:rule context="tei:note">
                                <sch:report test="string-length(.) eq 0">Empty note</sch:report>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>

                <elementSpec ident="seg" module="linking" mode="change">
                    <constraintSpec scheme="schematron" ident="seg_analysis">
                        <desc>Constraints to check the consistency of the semantic analysis</desc>
                        <constraint>
                            <!--                            Aligment:-->
                            <sch:rule
                                context="tei:seg[@function eq 'marker'][@copyOf][ancestor::tei:TEI/@xml:lang eq 'grc']">
                                <sch:let name="fileName"
                                    value="replace(base-uri(current()), '_grc', '_la')"/>
                                <sch:let name="document" value="doc($fileName)"/>
                                <sch:assert
                                    test="substring(@copyOf, 2) = $document//tei:seg[@function eq 'marker']/@xml:id"
                                    >Reference not present in aligned Gospel.</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:seg[@function eq 'marker'][@copyOf][ancestor::tei:TEI/@xml:lang eq 'la']">
                                <sch:let name="fileName"
                                    value="replace(base-uri(current()), '_la', '_grc')"/>
                                <sch:let name="document" value="doc($fileName)"/>
                                <sch:assert
                                    test="substring(@copyOf, 2) = $document//tei:seg[@function eq 'marker']/@xml:id"
                                    >Reference not present in aligned Gospel.</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:seg[@function eq 'marker'][@xml:id][ancestor::tei:TEI/@xml:lang eq 'la']">
                                <sch:let name="fileName"
                                    value="replace(base-uri(current()), '_la', '_grc')"/>
                                <sch:let name="document" value="doc($fileName)"/>
                                <sch:let name="ref" value="
                                    for $x in $document//tei:s/tokenize(@copyOf, '\s+')
                                    return
                                    substring($x, 2)"/>
                                <sch:assert test="
                                    if (@xml:id = $document//tei:seg[@function eq 'marker']/substring(@copyOf, 2)) then
                                    true()
                                    else
                                    @xml:id = $ref">Reference not
                                    present in aligned Gospel.</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:seg[@function eq 'marker'][@xml:id][ancestor::tei:TEI/@xml:lang eq 'grc']">
                                <sch:let name="fileName"
                                    value="replace(base-uri(current()), '_grc', '_la')"/>
                                <sch:let name="document" value="doc($fileName)"/>
                                <sch:let name="ref" value="
                                    for $x in $document//tei:s/tokenize(@copyOf, '\s+')
                                    return
                                    substring($x, 2)"/>
                                <sch:assert test="
                                    if (@xml:id = $document//tei:seg[@function eq 'marker']/substring(@copyOf, 2)) then
                                    true()
                                    else
                                    @xml:id = $ref">Reference not
                                    present in aligned Gospel.</sch:assert>
                            </sch:rule>
                            
<!--                            Other rules-->
                            <sch:rule context="tei:seg">
                                <sch:let name="function" value="@function"/>
                                <sch:let name="functions"
                                    value="('participant', 'negation', 'scope', 'marker')"/>
                                <sch:let name="part_types"
                                    value="('animate', 'inanimate', 'inanimate_patient', 'animate_patient')"/>
                                <sch:let name="ana" value="
                                    for $x in tokenize(@ana, '\s+')
                                    return
                                    substring($x, 2)"/>
                                <sch:assert test="@function = $functions">@function attribute is
                                    mandatory with one of these values: <sch:value-of
                                        select="$functions"/></sch:assert>
                                <sch:assert test="
                                    if (@ana) then
                                    every $x in tokenize(@ana, '\s+')
                                    satisfies substring($x, 2) = //tei:fs/@xml:id
                                    else
                                    true()">@ana does not have a
                                    corresponding ID in feature structures</sch:assert>
                                <sch:assert test="
                                    if (@part) then @ana
                                    else
                                    true()">@part requires the
                                    presence of an @ana attribute</sch:assert>
                                <sch:report test="tei:w/following-sibling::text()[matches(., '\S')]"
                                    >Segmentation issue</sch:report>
                                <sch:report test="descendant::tei:seg[@ana eq current()/@ana]"
                                    >Unnecessary nested segs</sch:report>
                                <sch:report test="
                                    if (@function eq 'marker') then
                                    descendant::tei:seg[@function eq 'marker']
                                    else
                                    false()">Unnecessary nested
                                    segs</sch:report>
                                <sch:assert test="
                                    if (@function eq 'participant') then
                                    @type = $part_types
                                    else
                                    true()">Attribute @type is
                                    mandatary with one of these values: <sch:value-of
                                        select="$part_types"/></sch:assert>
                                <sch:assert test="
                                    if (@function eq 'participant') then
                                    every $x in tokenize(@corresp, '\s+')
                                    satisfies substring($x, 2) = //tei:fs[@type eq 'scope']/@xml:id
                                    else
                                    true()">Attribute @corresp is
                                    missing or no corresponding ID was found in feature
                                    structures</sch:assert>
                                <sch:assert test="
                                    if (@function eq 'negation') then
                                    every $x in tokenize(@corresp, '\s+')
                                    satisfies substring($x, 2) = //tei:fs[@type = ('marker', 'scope')]/@xml:id
                                    else
                                    true()">Attribute @corresp is
                                    missing or no corresponding ID was found in feature
                                    structures</sch:assert>
                                <sch:assert test="
                                    if (@function = ('scope', 'marker')) then
                                   @ana
                                    else
                                    true()">@ana attribute is
                                    missing</sch:assert>
                                <sch:report test="
                                    if (@ana and not(@part)) then
                                    (following::tei:seg[some $x in tokenize(@ana, '\s+')
                                    satisfies $x = $ana] or preceding::tei:seg[some $x in tokenize(@ana, '\s+')
                                    satisfies $x = $ana])
                                    else
                                    false()">@part attribute
                                    missing</sch:report>
                                <sch:report test="
                                    if (@copyOf) then
                                    @copyOf = following::tei:seg/@copyOf
                                    else
                                    false()">Value of reference is
                                    not unique</sch:report>
                            </sch:rule>
                                              </constraint>
                    </constraintSpec>
                </elementSpec>
                <elementSpec ident="fs" module="iso-fs" mode="change">
                    <constraintSpec scheme="schematron" ident="seg_analysis">
                        <desc>Constraints to check the consistency of the semantic analysis</desc>
                        <constraint>
                            <sch:rule context="tei:fs[@type eq 'scope']">
                                <sch:assert
                                    test="tei:f[@name eq 'SoA'] or tei:f[@name eq 'dynamicity']">SoA
                                    description missing</sch:assert>
                                <sch:assert
                                    test="@xml:id = //tei:fs[@type eq 'relation']/tei:f[@name eq 'scope']/@fVal"
                                    >This scope is not part of a modal relation</sch:assert>
                                <sch:assert test="
                                    some $x in //tei:body//tei:seg[@function eq 'scope']/tokenize(@ana, '\s+')
                                    satisfies $x = '#' || current()/@xml:id"
                                    >ID not referenced in text</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:fs[@type eq 'marker']">
                                <sch:assert test="
                                    some $x in //tei:body//tei:seg[@function eq 'marker']/tokenize(@ana, '\s+')
                                    satisfies $x = '#' || current()/@xml:id"
                                    >ID not referenced in text</sch:assert>
                                <sch:assert test="
                                    if (tei:f[@name eq 'pertinence']/tei:binary/@value eq 'true') then
                                    @xml:id = //tei:fs[@type eq 'relation']/tei:f[@name eq 'marker']/@fVal
                                    else
                                    true()">This marker is not part
                                    of a modal relation</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:fs[@type eq 'relation']">
                                <sch:assert
                                    test="tei:f[@name eq 'marker']/@fVal = //tei:fs[@type eq 'marker']/@xml:id"
                                    >Marker ID not available</sch:assert>
                                <sch:assert
                                    test="tei:f[@name eq 'scope']/@fVal = //tei:fs[@type eq 'scope']/@xml:id"
                                    >Scope ID not available</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:fs[@type eq 'marker'][tei:f[@name eq 'pertinence'][tei:binary[@value eq 'true']]]">
                                <sch:assert test="tei:f[@name eq 'utterance']">Missing tei:f[@name
                                    eq 'utterance']</sch:assert>
                                <sch:assert test="tei:f[@name eq 'polarity']">Missing tei:f[@name eq
                                    'polarity']</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:fs[@type eq 'marker']">
                                <sch:assert test="tei:f[@name = ('pertinence', 'modal')]"> One of
                                    the following features is required: 'pertinence,
                                    modal'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:fs[@type eq 'scope'][tei:f[@name eq 'dynamicity']]">
                                <sch:assert test="tei:f[@name eq 'control']">Missing tei:f[@name eq
                                    'control']</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:fs[@type eq 'scope'][tei:f[@name eq 'control']]">
                                <sch:assert test="tei:f[@name eq 'dynamicity']">Missing tei:f[@name
                                    eq 'dynamicity']</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:fs[@type eq 'scope']">
                                <sch:assert test="tei:f[@name = ('utterance', 'polarity')]"> One of
                                    the following features is required: 'utterance,
                                    polarity'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:fs[@type eq 'relation'][tei:f[@name eq 'modality'][tei:symbol[@value eq 'dynamic']]]">
                                <sch:assert test="tei:f[@name eq 'type']">Missing tei:f[@name eq
                                    'type']</sch:assert>
                                <sch:assert
                                    test="tei:f[@name eq 'type']/tei:symbol/@value = ('possibility', 'necessity')"
                                    >Possible values of tei:f[@name eq 'type'] are 'possibility'
                                    'necessity'</sch:assert>
                                <sch:assert test="tei:f[@name eq 'participant_control']">Missing
                                    tei:f[@name eq 'participant_control']</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:fs[@type eq 'relation'][tei:f[@name eq 'modality'][tei:symbol[@value eq 'deontic']]]">
                                <sch:assert test="tei:f[@name eq 'type']">Missing tei:f[@name eq
                                    'type']</sch:assert>
                                <sch:assert
                                    test="tei:f[@name eq 'type']/tei:symbol/@value = ('authority', 'acceptability', 'volition', 'intention')"
                                    >Possible values of tei:f[@name eq 'type'] are 'authority'
                                    'acceptability' 'volition' 'intention'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:fs[@type eq 'relation'][tei:f[@name eq 'type'][tei:symbol[@value eq 'authority']]]">
                                <sch:assert test="tei:f[@name eq 'subtype']">Missing tei:f[@name eq
                                    'subtype']</sch:assert>
                                <sch:assert
                                    test="tei:f[@name eq 'subtype']/tei:symbol/@value = ('obligation', 'recommendation', 'permission')"
                                    >Possible values of tei:f[@name eq 'subtype'] are 'obligation'
                                    'recommendation' 'permission'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:fs[@type eq 'relation'][tei:f[@name eq 'type'][tei:symbol[@value eq 'acceptability']]]">
                                <sch:assert test="tei:f[@name eq 'degree']">Missing tei:f[@name eq
                                    'degree']</sch:assert>
                                <sch:assert
                                    test="tei:f[@name eq 'degree']/tei:symbol/@value = ('absolutely_necessary', 'desirable', 'acceptable', 'undesirable', 'unacceptable')"
                                    >Possible values of tei:f[@name eq 'degree'] are
                                    'absolutely_necessary' 'desirable' 'acceptable' 'undesirable'
                                    'unacceptable'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:fs[@type eq 'relation'][tei:f[@name eq 'modality'][tei:symbol[@value eq 'epistemic']]]">
                                <sch:assert test="tei:f[@name eq 'degree']">Missing tei:f[@name eq
                                    'degree']</sch:assert>
                                <sch:assert
                                    test="tei:f[@name eq 'degree']/tei:symbol/@value = ('absolutely_certain', 'probable', 'possible', 'improbable', 'impossible')"
                                    >Possible values of tei:f[@name eq 'degree'] are
                                    'absolutely_certain' 'probable' 'possible' 'improbable'
                                    'impossible'</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:fs[@type eq 'relation']">
                                <sch:assert test="tei:f[@name = ('modality')]"> One of the following
                                    features is required: 'modality'</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>
                <elementSpec ident="f" module="iso-fs" mode="change">
                    <constraintSpec scheme="schematron" ident="seg_analysis">
                        <desc>Constraints to check the consistency of the semantic analysis</desc>
                        <constraint>
                            <sch:rule
                                context="tei:f[@name eq 'pertinence'][parent::tei:fs[@type eq 'marker']]">
                                <sch:assert test="tei:binary">Mandatory binary feature</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'modal'][parent::tei:fs[@type eq 'marker']]">
                                <sch:assert test="tei:binary">Mandatory binary feature</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'diachrony'][parent::tei:fs[@type eq 'marker']]">
                                <sch:assert test="tei:symbol[@value = ('post-modal', 'pre-modal')]">
                                    Incorrect value of @value. Possible values are: 'post-modal,
                                    pre-modal'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'utterance'][parent::tei:fs[@type eq 'marker']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('non-interrogative', 'interrogative')]"
                                    > Incorrect value of @value. Possible values are:
                                    'non-interrogative, interrogative'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'polarity'][parent::tei:fs[@type eq 'marker']]">
                                <sch:assert test="tei:symbol[@value = ('affirmative', 'negative')]">
                                    Incorrect value of @value. Possible values are: 'affirmative,
                                    negative'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'utterance'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('non-interrogative', 'interrogative')]"
                                    > Incorrect value of @value. Possible values are:
                                    'non-interrogative, interrogative'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'polarity'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert test="tei:symbol[@value = ('affirmative', 'negative')]">
                                    Incorrect value of @value. Possible values are: 'affirmative,
                                    negative'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'control'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert test="tei:symbol[@value = ('+-')] or tei:binary">
                                    Incorrect value. Possible values are: a binary element or a
                                    symbol element with one of the following @value attributes
                                    '+-'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'dynamicity'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert test="tei:symbol[@value = ('+-')] or tei:binary">
                                    Incorrect value. Possible values are: a binary element or a
                                    symbol element with one of the following @value attributes
                                    '+-'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'SoA'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert test="tei:binary/@value eq 'false'">SoA value is
                                    expected to be false. If SoA is present, then control and
                                    dynamicity must be expressed</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'participant'][parent::tei:fs[@type eq 'scope']]">
                                <sch:assert test="tei:symbol[@value = ('animate', 'inanimate', 'animate_patient', 'inanimate_patient', 'none')]">
                                    Incorrect value. Possible values are: 'animate, inanimate, animate_patient, inanimate_patient, none'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'modality'][parent::tei:fs[@type eq 'relation']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('deontic', 'dynamic', 'epistemic')]">
                                    Incorrect value of @value. Possible values are: 'deontic,
                                    dynamic, epistemic'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'subtype'][parent::tei:fs[@type eq 'relation']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('obligation', 'recommendation', 'permission', 'prospective', 'inevitability')]"
                                    > Incorrect value of @value. Possible values are: 'obligation,
                                    recommendation, permission, prospective,
                                    inevitability'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'participant_control'][parent::tei:fs[@type eq 'relation']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('participant-imposed', 'participant-inherent', 'situational')]"
                                    > Incorrect value of @value. Possible values are:
                                    'participant-imposed, participant-inherent,
                                    situational'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'function'][parent::tei:fs[@type eq 'relation']]">
                                <sch:assert test="tei:symbol[@value = ('rhetoric', 'pragmatic')]">
                                    Incorrect value of @value. Possible values are: 'rhetoric,
                                    pragmatic'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'context'][parent::tei:fs[@type eq 'relation']]">
                                <sch:assert test="tei:symbol[@value = ('non-official', 'official')]"
                                    > Incorrect value of @value. Possible values are: 'non-official,
                                    official'</sch:assert>
                            </sch:rule>
                            <sch:rule
                                context="tei:f[@name eq 'source'][parent::tei:fs[@type eq 'relation']]">
                                <sch:assert
                                    test="tei:symbol[@value = ('moral/ethical_norms', 'religious_norms', 'unspecified_norms')]"
                                    > Incorrect value of @value. Possible values are:
                                    'moral/ethical_norms, religious_norms,
                                    unspecified_norms'</sch:assert>
                            </sch:rule>
                            <!--      Verb features-->
                            <sch:rule context="tei:f[@name eq 'Tense']">
                                <sch:assert
                                    test="tei:symbol/@value = ('Fut', 'Past', 'Pqp', 'Pres')"
                                    >Possible values: Fut, Past, Pqp, Pres</sch:assert>
                                <sch:assert test="parent::tei:fs/tei:f[@name eq 'Voice']">Voice
                                    feature is mandatory</sch:assert>
                                <sch:assert test="
                                    if (tei:symbol/@value eq 'Past') then
                                    parent::tei:fs/tei:f[@name eq 'Aspect']
                                    else
                                    true()">Aspect feature is
                                    mandatory</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:f[@name eq 'VerbForm']">
                                <sch:assert
                                    test="tei:symbol/@value = ('Fin', 'Gdv', 'Ger', 'Inf', 'Part')"
                                    >Possible values: Fin, Gdv, Ger, Inf, Part.</sch:assert>
                                <sch:assert test="
                                    if (tei:symbol/@value = ('Inf', 'Part')) then
                                    parent::tei:fs/tei:f[@name eq 'Tense']
                                    else
                                    true()">Voice feature is
                                    mandatory</sch:assert>
                                <sch:assert test="
                                    if (tei:symbol/@value = 'Fin') then
                                    parent::tei:fs/tei:f[@name eq 'Person'] and parent::tei:fs/tei:f[@name eq 'Number'] 
                                    and parent::tei:fs/tei:f[@name eq 'Mood'] and parent::tei:fs/tei:f[@name eq 'Tense']
                                    else
                                    true()">Person, Number, Mood and
                                    Tense features are mandatory</sch:assert>
                                <sch:assert test="
                                    if (tei:symbol/@value = ('Gdv', 'Part')) then
                                    parent::tei:fs/tei:f[@name eq 'Case'] and
                                    parent::tei:fs/tei:f[@name eq 'Gender'] and parent::tei:fs/tei:f[@name eq 'Number']
                                    else
                                    true()">Case, Person and Number
                                    features are mandatory</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:f[@name eq 'Aspect']">
                                <sch:assert test="tei:symbol/@value = ('Imp', 'Perf')">Possible
                                    values: Imp, Perf.</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:f[@name eq 'Number']">
                                <sch:assert test="tei:symbol/@value = ('Plur', 'Sing')">Possible
                                    values: Plur, Sing.</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:f[@name eq 'Voice']">
                                <sch:assert test="tei:symbol/@value = ('Act', 'Pass')">Possible
                                    values: Act, Pass.</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:f[@name eq 'Mood']">
                                <sch:assert test="tei:symbol/@value = ('Imp', 'Ind', 'Sub')"
                                    >Possible values: Imp, Ind, Sub</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:f[@name eq 'Person']">
                                <sch:assert test="tei:symbol/@value = ('1', '2', '3')">Possible
                                    values: 1, 2, 3.</sch:assert>
                            </sch:rule>
                            <!--      Noun features-->
                            <sch:rule context="tei:f[@name eq 'Gender']">
                                <sch:assert test="tei:symbol/@value = ('Masc', 'Fem', 'Neut')"
                                    >Possible values: Masc, Fem, Neut.</sch:assert>
                                <sch:assert
                                    test="parent::tei:fs/tei:f[@name eq 'Number'] and parent::tei:fs/tei:f[@name eq 'Case']"
                                    >Number feature is mandatory</sch:assert>
                            </sch:rule>
                            <sch:rule context="tei:f[@name eq 'Case']"> <sch:assert
                                    test="tei:symbol/@value = ('Abl', 'Acc', 'Dat', 'Gen', 'Loc', 'Nom', 'Voc')"
                                    >Possible values: Abl, Acc, Dat, Gen, Loc, Nom,
                                    Voc.</sch:assert>
                            </sch:rule>
                            <!--         Other-->
                            <sch:rule context="tei:f[@name eq 'Degree']">
                                <sch:assert test="tei:symbol/@value = ('Cmp', 'Pos', 'Sup')"
                                    >Possible values: Cmp, Pos, Sup.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>
            </schemaSpec>
        </body>
    </text>
</TEI>
